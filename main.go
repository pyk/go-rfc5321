package main

import (
	"bufio"
	"errors"
	"fmt"
	"log"
	"net"
	"runtime"
	"strings"
	"unicode"

	"github.com/pkg/profile"
)

// TODO: konsep transaction di dalam session
// wrap semua reply dan command jadi sebuah
// transaction. misal transaction.r.EHLO
// transaction.c.EHLO
// reply & command should created by session
// how about transaction btw? bukankah transaction
// lah sebagai wadah untuk command dan reply
//
// TODO: add receiver and sender inside Session
// we MUST know information about sender, so we can
// decide should process or reject it
type Session struct {
	id   int
	Conn net.Conn
}

func (s *Session) Close() error {
	log.Printf("S%d: Closed", s.id)
	err := s.Conn.Close()
	if err != nil {
		return err
	}
	return nil
}

// TODO: receiver should transmit a reply
// seharusnya session bukan yang mengirim reply
// tapi receiverlah yang ngirim reply dan baca command
// terus hubungannya session sama receiver apa?
// ya session itu wadah lalu receiver itu yang kerja
// lalu clientnya disebut sender, pengirim command

func (s *Session) New() {
	defer s.Close()

	// TODO: 540 reject session jika diperlukan, sesi
	// seperti apa yang harus di reject?
	// tapi harus nunngu command QUIT untuk close connection
	// dan sebelum mengirim QUIT harus reply 503 sebagai
	// bad sequences of command

	err := reply("220 Maillennia").Transmit(s.Conn)
	if err != nil {
		log.Printf("S%d: %s", s.id, err.Error())
		// TODO: how handle error on session?
		// close session?
	}

	for {
		// wait for line received
		buffReader := bufio.NewReader(s.Conn)
		line, _, err := buffReader.ReadLine()
		if err != nil {
			// if error happen we close the session
			break
		}
		c := command(line)
		log.Println(c.Verb())
		log.Println(c.Arg())
		// switch c.Verb() {
		// case "HELO", "EHLO":
		// 	s.handleHello(line.Verb(), line.Arg())
		// case "QUIT":
		// 	s.sendlinef("221 2.0.0 Bye")
		// 	return
		// case "RSET":
		// 	s.env = nil
		// 	s.sendlinef("250 2.0.0 OK")
		// case "NOOP":
		// 	s.sendlinef("250 2.0.0 OK")
		// case "MAIL":
		// 	arg := line.Arg() // "From:<foo@bar.com>"
		// 	m := mailFromRE.FindStringSubmatch(arg)
		// 	if m == nil {
		// 		log.Printf("invalid MAIL arg: %q", arg)
		// 		s.sendlinef("501 5.1.7 Bad sender address syntax")
		// 		continue
		// 	}
		// 	s.handleMailFrom(m[1])
		// case "RCPT":
		// 	s.handleRcpt(line)
		// case "DATA":
		// 	s.handleData()
		// default:
		// 	log.Printf("Client: %q, verhb: %q", line, line.Verb())
		// 	s.sendlinef("502 5.5.2 Error: command not recognized")
		// }
		// selection of process

		// command received, start process
		// 1. receiver identifying
		// 2. receiver validating
		// 3. receiver process

		log.Println(string(line))
		// if command received then
		// process command session.NewCommand(line)
		// command.valid?
		// command.prefix() select bla bla

		// TODO: handle EHLO dan HELO command

		// TODO: jika command QUIT maka break
		// TODO: jika CTRL+C maka break
	}
}

// reply is generated by receiver and transmitted to sender
// via session connection
type reply string

// Transmit write a Reply to connection writer
func (rp reply) Transmit(conn net.Conn) error {
	w := bufio.NewWriter(conn)
	fmt.Fprintf(w, "%s\r\n", string(rp))
	err := w.Flush()
	if err != nil {
		return errors.New("Error while send a Reply")
	}
	return nil
}

type command string

func (c command) Verb() string {
	cl := string(c)
	if i := strings.Index(cl, " "); i != -1 {
		return strings.ToUpper(cl[:i])
	}
	return strings.ToUpper(cl[:len(cl)-2])
}

func (c command) Arg() string {
	cl := string(c)
	if i := strings.Index(cl, " "); i != -1 {
		return strings.TrimRightFunc(cl[i+1:len(cl)-2], unicode.IsSpace)
	}
	return ""
}

func main() {
	defer profile.Start(profile.MemProfile).Stop()
	runtime.GOMAXPROCS(1)

	// create a server
	tcpAddr, err := net.ResolveTCPAddr("tcp4", ":8080")
	if err != nil {
		log.Fatal(err)
	}
	listener, err := net.ListenTCP("tcp", tcpAddr)
	if err != nil {
		log.Fatal(err)
	}
	defer listener.Close()
	log.Printf("SMTP server listening on %s", listener.Addr())

	num := 0
	for {
		log.Printf("%d waiting for the next transmission", num)
		// wait for transmission channel estabilished
		conn, err := listener.Accept()
		if err != nil {
			log.Printf("maillennia: Accept: %v", err)
			continue
		}

		// TOOD: Informasi apa yang bisa kita dapat pada conn?
		// jadi kita bisa tau addr nya sender
		// log.Println(conn.RemoteAddr().Network())
		// log.Println(conn.RemoteAddr().String())
		// kita juga bisa tau addr nya receiver
		// log.Println(conn.LocalAddr().Network())
		// log.Println(conn.LocalAddr().String())
		// terus informasi apa yang bisa kita dapat dari address tersebut?
		// bagaimana cara tahu kalo sender itu dari mailicious atau spam?
		// ssssttt, kapan prosedur pengecekan ini dilakukan saaya belum tau.
		// jadi kita kumpulkan data dulu aja, baru nanti kelanjutannya gimana

		// start new session of transmission
		session := Session{
			id: num,
			// sender:
			Conn: conn,
		}

		// receiver:
		// what receiver do? he read a command and transmit a reply
		// what tool are needed by receiver to do that?
		// for read command receiver need bufio.Newreader
		// to transmit command it need bufio.NewWriter
		// and both bufio need a conn. so in case of creating
		// receiver you need conn.
		// btw, what recevier looks like?
		// a := rcv.NewReply(220, "'i'll be your good listener")
		// a.Transmit()
		// jadi reader bukan inside session cuy, tapi sebagai argumen
		// dari session.new(receiver, sender)
		// terus, bagaimana cara dia baca command?
		// line, err := rcv.ReadLine()
		//

		// handle every new session concurrently
		go session.New()
		num += 1
	}
}

package main

import (
	"bufio"
	"errors"
	"fmt"
	"log"
	"net"
	"runtime"
	"strings"
	"unicode"

	"github.com/pkg/profile"
)

// define replies
const (
	REPLY_220 = "220 Maillennia ready"
	REPLY_440 = "440 Command not received. Please try again"
)

// Session represents session on new connection
type Session struct {
	id   int
	Conn net.Conn
}

// Close close the session
func (s *Session) Close() error {
	log.Printf("S%d: Closed", s.id)
	err := s.Conn.Close()
	if err != nil {
		return err
	}
	return nil
}

// New create a new session
func (s *Session) New() {
	defer s.Close()

	// TODO: 540 reject session jika diperlukan, sesi
	// seperti apa yang harus di reject?
	// tapi harus nunngu command QUIT untuk close connection
	// dan sebelum mengirim QUIT harus reply 503 sebagai
	// bad sequences of command

	err := reply(REPLY_220).Transmit(s.Conn)
	if err != nil {
		log.Printf("S%d: %v", s.id, err)
		return
	}

	for {
		// wait for line received
		buffReader := bufio.NewReader(s.Conn)
		line, _, err := buffReader.ReadLine()
		if err != nil {
			err := reply(REPLY_440).Transmit(s.Conn)
			if err != nil {
				log.Printf("S%d: %v", s.id, err)
				return
			}
		}

		// TODO: process the command received
		// see an Verb and Arg
		c := command(line)
		log.Println(c.Verb())
		log.Println(c.Arg())

		// TODO: handle EHLO dan HELO command
		// switch c.Verb() {
		// case "HELO", "EHLO":
		// 	s.handleHello(line.Verb(), line.Arg())
		// case "QUIT":
		// 	s.sendlinef("221 2.0.0 Bye")
		// 	return
		// case "RSET":
		// 	s.env = nil
		// 	s.sendlinef("250 2.0.0 OK")
		// case "NOOP":
		// 	s.sendlinef("250 2.0.0 OK")
		// case "MAIL":
		// 	arg := line.Arg() // "From:<foo@bar.com>"
		// 	m := mailFromRE.FindStringSubmatch(arg)
		// 	if m == nil {
		// 		log.Printf("invalid MAIL arg: %q", arg)
		// 		s.sendlinef("501 5.1.7 Bad sender address syntax")
		// 		continue
		// 	}
		// 	s.handleMailFrom(m[1])
		// case "RCPT":
		// 	s.handleRcpt(line)
		// case "DATA":
		// 	s.handleData()
		// default:
		// 	log.Printf("Client: %q, verhb: %q", line, line.Verb())
		// 	s.sendlinef("502 5.5.2 Error: command not recognized")
		// }
		// selection of process

		// command received, start process
		// 1. receiver identifying
		// 2. receiver validating
		// 3. receiver process

		log.Println(string(line))
		// if command received then
		// process command session.NewCommand(line)
		// command.valid?
		// command.prefix() select bla bla

		// TODO: handle EHLO dan HELO command

		// TODO: jika command QUIT maka break
		// TODO: jika CTRL+C maka break
	}
}

// reply is generated by receiver and transmitted to sender
// via session connection
type reply string

// Transmit write a Reply to connection writer
func (rp reply) Transmit(conn net.Conn) error {
	w := bufio.NewWriter(conn)
	fmt.Fprintf(w, "%s\r\n", string(rp))
	err := w.Flush()
	if err != nil {
		return errors.New("Error while send a Reply")
	}
	return nil
}

type command string

func (c command) Verb() string {
	cl := string(c)
	if i := strings.Index(cl, " "); i != -1 {
		return strings.ToUpper(cl[:i])
	}
	return strings.ToUpper(cl[:len(cl)-2])
}

func (c command) Arg() string {
	cl := string(c)
	if i := strings.Index(cl, " "); i != -1 {
		return strings.TrimRightFunc(cl[i+1:len(cl)-2], unicode.IsSpace)
	}
	return ""
}

func main() {
	defer profile.Start(profile.MemProfile).Stop()
	runtime.GOMAXPROCS(1)

	// create a server
	tcpAddr, err := net.ResolveTCPAddr("tcp4", ":8080")
	if err != nil {
		log.Fatal(err)
	}
	listener, err := net.ListenTCP("tcp", tcpAddr)
	if err != nil {
		log.Fatal(err)
	}
	defer listener.Close()
	log.Printf("SMTP server listening on %s", listener.Addr())

	num := 0
	for {
		log.Printf("%d waiting for the next transmission", num)
		// wait for transmission channel estabilished
		conn, err := listener.Accept()
		if err != nil {
			log.Printf("maillennia: Accept: %v", err)
			continue
		}

		// start new session of transmission
		session := Session{
			id:   num,
			Conn: conn,
		}

		// handle every new session concurrently
		go session.New()
		num += 1
	}
}

package main

import (
	"bufio"
	"errors"
	"fmt"
	"log"
	"net"
	"runtime"
	"strings"

	"github.com/pkg/profile"
)

// define replies
const (
	REPLY_220 = "220 Maillennia ready"
	REPLY_440 = "440 Command not received. Please try again"
	REPLY_502 = "502 5.5.1 Unrecognized command."
)

// Session represents session on new connection
type Session struct {
	id       int
	Conn     net.Conn
	Validity bool
	Reader   *bufio.Reader
	Writer   *bufio.Writer
}

// Close close the session
func (s *Session) Close() error {
	log.Printf("S%d: Closed", s.id)
	err := s.Conn.Close()
	if err != nil {
		return err
	}
	return nil
}

func (s *Session) SetValid(valid bool) {
	s.Validity = true
}

func (s *Session) Valid() bool {
	return s.Validity
}

// New create a new session
func (s *Session) New() {
	defer s.Close()

	// TODO: 540 reject session jika diperlukan, sesi
	// seperti apa yang harus di reject?
	// tapi harus nunngu command QUIT untuk close connection
	// dan sebelum mengirim QUIT harus reply 503 sebagai
	// bad sequences of command

	err := reply(REPLY_220).Transmit(s.Conn)
	if err != nil {
		log.Printf("S%d: %v", s.id, err)
		return
	}

	for {
		// read from connection, return non-escaped string include \r\n
		line, err := s.Reader.ReadString('\n')
		if err != nil {
			err := reply(REPLY_440).Transmit(s.Conn)
			if err != nil {
				log.Printf("S%d: %v", s.id, err)
				return
			}
		}

		c := command(line)
		valid, err := c.Valid()
		if !valid && err != nil {
			e := reply(REPLY_502).WithErr(err).Transmit(s.Conn)
			if e != nil {
				log.Printf("S%d: %v", s.id, err)
				return
			}
		}
		// TODO: setiap sesi harus diawali dengan hello command
		// kalo tidak diawali maka sesi tidak valid

		// TODO: handle EHLO dan HELO command
		// switch c.Verb() {
		// case "EHLO":
		// 	s.SetValid(true)
		// 	log.Println(c.Verb())
		// 	log.Println(c.Arg())
		// case "QUIT":
		// 	// TODO: terminate connection
		// 	log.Println(c.Verb())
		// 	log.Println(c.Arg())
		// case "":
		// 	log.Println(c.Verb())
		// 	log.Println(c.Arg())
		// 	log.Println("enter")
		// default:
		// 	log.Println(c.Verb())
		// 	log.Println(c.Arg())
		// 	err := reply(REPLY_502).Transmit(s.Conn)
		// 	if err != nil {
		// 		log.Printf("S%d: %v", s.id, err)
		// 		return
		// 	}
		// }

		// TODO: jika command QUIT maka break
		// TODO: jika CTRL+C maka break
	}
}

// reply is generated by receiver and transmitted to sender
// via session connection
type reply string

func (rp reply) WithErr(err error) reply {
	return reply(rp + err.Error())
}

// Transmit write a Reply to connection writer
func (rp reply) Transmit(conn net.Conn) error {
	w := bufio.NewWriter(conn)
	fmt.Fprintf(w, "%s\r\n", string(rp))
	err := w.Flush()
	if err != nil {
		return errors.New("Error while send a Reply")
	}
	return nil
}

type command string

func (c command) String() string {
	return string(c)
}

func (c command) Valid() (bool, error) {
	// TODO: every command should terminated with <CRLF>
	if r := strings.HasSuffix(c.String(), "/r/n"); !r {
		return false, errors.New("Command not terminated with <CRLF>")
	}
	return true, nil
}
func (c command) Verb() string {
	// TODO: extract verb from command string
	s := strings.Split(string(c), " ")
	return strings.ToUpper(s[0])
}

func (c command) Arg() string {
	// TODO: extract argument from command string
	s := strings.Split(string(c), " ")
	if len(s) > 1 {
		return s[1]
	}
	return ""
}

func (c command) Len() int {
	return len(string(c))
}

func main() {
	defer profile.Start(profile.MemProfile).Stop()
	runtime.GOMAXPROCS(1)

	// create a server
	tcpAddr, err := net.ResolveTCPAddr("tcp4", ":8080")
	if err != nil {
		log.Fatal(err)
	}
	listener, err := net.ListenTCP("tcp", tcpAddr)
	if err != nil {
		log.Fatal(err)
	}
	defer listener.Close()
	log.Printf("SMTP server listening on %s", listener.Addr())

	num := 0
	for {
		log.Printf("%d waiting for the next transmission", num)
		// wait for transmission channel estabilished
		conn, err := listener.Accept()
		if err != nil {
			log.Printf("maillennia: Accept: %v", err)
			continue
		}

		// start new session of transmission
		session := Session{
			id:       num,
			Conn:     conn,
			Validity: false,
			Reader:   bufio.NewReader(conn),
			Writer:   bufio.NewWriter(conn),
		}

		// handle every new session concurrently
		go session.New()
		num += 1
	}
}
